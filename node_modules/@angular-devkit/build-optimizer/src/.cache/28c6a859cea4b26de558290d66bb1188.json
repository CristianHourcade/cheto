{"remainingRequest":"/opt/lampp/htdocs/dashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/opt/lampp/htdocs/dashboard/node_modules/mercadopago/lib/utils/mercadopagoResponse.js","dependencies":[{"path":"/opt/lampp/htdocs/dashboard/node_modules/mercadopago/lib/utils/mercadopagoResponse.js","mtime":1528162934000},{"path":"/opt/lampp/htdocs/dashboard/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/opt/lampp/htdocs/dashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var Promise = require('bluebird');\nvar configurations = require('../configurations');\nvar preConditions = require('../precondition');\n\n// Private variables to hide them from the integrator\nvar requestManager;\nvar execOptions;\n\nvar mercadopagoResponse = function mercadopagoResponse(body, status, idempotencyId, pagination, options, requestManagerInjection) {\n  this.body = body;\n  this.response = this.body;\n  this.status = status;\n  this.idempotency = idempotencyId;\n  this.pagination = pagination;\n\n  execOptions = options;\n  requestManager = requestManagerInjection;\n};\n\n/**\n * Execute request using the requestManager and execOptions\n * @param resolve\n * @param reject\n * @param callback\n * @returns {*}\n */\nvar executeRequest = function (resolve, reject, callback) {\n  callback = preConditions.getCallback(callback);\n\n  return requestManager.generateAccessToken().then(function () {\n    return requestManager.exec(execOptions);\n  }).then(function (response) {\n    resolve(response);\n    return callback.apply(null, [null, response]);\n  }).catch(function (err) {\n    reject(err);\n    return callback.apply(null, [err, null]);\n  });\n};\n\n/**\n * Execute previous page request using the requestManager\n * @param callback\n */\nmercadopagoResponse.prototype.prev = function (callback) {\n  var error;\n\n  callback = preConditions.getCallback(callback);\n\n  return new Promise(function (resolve, reject) {\n    var previousPage;\n\n    if (!this.pagination) {\n      error = new Error('This response doesnt support pagination');\n      reject(error);\n      return callback.apply(null, [error, null]);\n    }\n\n    // Set previous page\n    previousPage = this.pagination.offset - this.pagination.limit;\n\n    // Setting the new limit and offset\n    execOptions.config.qs.limit = this.pagination.limit;\n    execOptions.config.qs.offset = (previousPage >= 0) ? previousPage : 0;\n\n    return executeRequest(resolve, reject, callback);\n  }.bind(this));\n};\n\n/**\n * Execute next page request using the requestManager\n * @param callback\n */\nmercadopagoResponse.prototype.next = function (callback) {\n  var error;\n\n  callback = preConditions.getCallback(callback);\n\n  return new Promise(function (resolve, reject) {\n    if (!this.pagination) {\n      error = new Error('This response doesnt support pagination');\n      reject(error);\n      return callback.apply(null, [error, null]);\n    }\n\n    // Setting the new limit and offset\n    execOptions.config.qs.limit = this.pagination.limit;\n    execOptions.config.qs.offset = this.pagination.offset + this.pagination.limit;\n\n    return executeRequest(resolve, reject, callback);\n  }.bind(this));\n};\n\n/**\n * Check if it haves a previous page\n * @returns {boolean}\n */\nmercadopagoResponse.prototype.hasPrev = function () {\n  return (this.pagination && (this.pagination.offset > 0));\n};\n\n/**\n * Check if it haves a next page\n * @returns {boolean}\n */\nmercadopagoResponse.prototype.hasNext = function () {\n  return (this.pagination && ((this.pagination.offset + this.pagination.limit) < this.pagination.total));\n};\n\n/**\n * Get exec options\n * @returns {*}\n */\nmercadopagoResponse.prototype.getExecOptions = function () {\n  return execOptions;\n};\n\nmodule.exports = mercadopagoResponse;\n",null]}