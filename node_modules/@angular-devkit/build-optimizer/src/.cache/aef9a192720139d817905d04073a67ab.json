{"remainingRequest":"/opt/lampp/htdocs/dashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--3-1!/opt/lampp/htdocs/dashboard/node_modules/mercadopago/lib/request-manager.js","dependencies":[{"path":"/opt/lampp/htdocs/dashboard/node_modules/mercadopago/lib/request-manager.js","mtime":1533070137000},{"path":"/opt/lampp/htdocs/dashboard/node_modules/cache-loader/dist/cjs.js","mtime":0},{"path":"/opt/lampp/htdocs/dashboard/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["var request = require('request');\nvar Promise = require('bluebird');\nvar uuid = require('uuid');\nvar configurations = require('./configurations');\nvar MercadopagoResponse = require('./utils/mercadopagoResponse');\nvar MercadoPagoError = require('./utils/mercadopagoError');\nvar validation = require('./validation');\nvar ETagRequest = require('request-etag');\nvar preConditions = require('./precondition');\n\nvar requestManager = module.exports = {\n  JSON_MIME_TYPE: 'application/json',\n  FORM_MIME_TYPE: 'application/x-www-form-urlencoded',\n  REST_CLIENT: new ETagRequest({\n    max: configurations.cache_max_size\n  }, request)\n};\n\n/**\n * Creates a dynamic function depending on the options that are send by the resources\n * @param options\n * @returns {Function}\n */\nrequestManager.describe = function (options) {\n  // This method will have the context of the class that is calling this (Will have the context of the class)\n  return function () {\n    var optMethod = requestManager.clone({}, options);\n    var calledArgs = arguments;\n\n    return new Promise(function (resolve, reject) {\n      var callback = calledArgs[calledArgs.length - 1]; // Last argument will always be the callback\n      var pathParameters = requestManager.getPathParamsKeyNames(optMethod.path);\n      var missingPayloadProperties = []; // Stores the missing payload path params (if there is any). POST, PUT, PATCH\n      var schema = this.schema; // Schema from resource\n      var needIdempotency = !!this.idempotency; // Idempotency from resource\n      var config = {};\n      var payload = {};\n      var error;\n      var totalFunctionParams;\n      var haveConfig = false;\n\n      // If callback doesn't exists add it to the arguments (Prevent code to fail)\n      if (typeof callback !== 'function' || callback === undefined) {\n        // Arguments is not a pure array. You need to make a normal array out of it. If not arguments.length won't work\n        calledArgs = Array.prototype.slice.call(calledArgs);\n        calledArgs.push(callback = function () {});\n      }\n\n      // If it is GET or DELETE the path variables needs to come from arguments\n      if (optMethod.method === 'GET' || optMethod.method === 'DELETE') {\n        haveConfig = (typeof calledArgs[calledArgs.length - 2] === 'object');\n        totalFunctionParams = (haveConfig) ? (pathParameters.length + 2) : (pathParameters.length + 1);\n\n        // Set the configurations\n        if (haveConfig) config = calledArgs[calledArgs.length - 2];\n\n        // Verify arguments quantity (invalid function call)\n        if (totalFunctionParams > calledArgs.length) {\n          error = new Error('Expecting parameters: ' + pathParameters.join(', ').replace(/:/g, ''));\n          reject(error);\n          return callback.apply(null, [error, null]);\n        }\n\n        // Replace the path parameters for the variables from the args(same Index that the one declarated on the path)\n        pathParameters.forEach(function (param, index) {\n          optMethod.path = optMethod.path.replace(param, calledArgs[index]);\n        });\n      } else {\n        haveConfig = (calledArgs.length > 2);\n\n        // If configurations are sent, set configurations and payload depending on the correspondent argument index\n        if (haveConfig) {\n          if (typeof calledArgs[calledArgs.length - 2] === 'object') config = calledArgs[calledArgs.length - 2];\n          if (typeof calledArgs[calledArgs.length - 3] === 'object') payload = calledArgs[calledArgs.length - 3];\n        } else if (typeof calledArgs[calledArgs.length - 2] === 'object') {\n          payload = calledArgs[calledArgs.length - 2];\n        }\n\n        // Replace the path parameters from the ones on the payload\n        pathParameters.forEach(function (param) {\n          var propertyFromPayload = param.replace(':', '');\n\n          if (payload && payload[propertyFromPayload]) {\n            optMethod.path = optMethod.path.replace(param, payload[propertyFromPayload]);\n            // Remove it from the payload or MercadoPago API will return an error for invalid parameter\n            delete payload[propertyFromPayload];\n          } else {\n            missingPayloadProperties.push(propertyFromPayload);\n          }\n        });\n\n        // If there are any missing properties show an error (invalid function call)\n        if (missingPayloadProperties.length > 0) {\n          error = new Error('The JSON is missing the following properties: ' + missingPayloadProperties.join(', '));\n          reject(error);\n          return callback.apply(null, [error, null]);\n        }\n      }\n\n      // If the path requires /sandbox prefix on sandbox mode, prepend it\n      if (optMethod.path_sandbox_prefix !== undefined && optMethod.path_sandbox_prefix && configurations.sandbox) {\n        optMethod.path = '/sandbox' + optMethod.path;\n      }\n\n      // Generate the AccessToken first (required to work with MercadoPago API)\n      return requestManager.generateAccessToken().then(function (accessToken) {\n        return requestManager.exec({\n          schema: schema,\n          base_url: (optMethod.base_url !== undefined) ? optMethod.base_url : '', // Overrides the base URI\n          path: optMethod.path,\n          method: optMethod.method,\n          config: config, // Configurations object\n          payload: payload, // Payload to send\n          idempotency: needIdempotency, // Needs the idempotency header\n          // If the merchant provides an access_token, it should override the access_token configured on init\n          access_token: config.access_token ? config.access_token : accessToken,\n        });\n      }).then(function (response) {\n        resolve(response);\n        return callback.apply(null, [null, response]);\n      }).catch(function (err) {\n        reject(err);\n        return callback.apply(null, [err, null]);\n      });\n    }.bind(this));\n  };\n};\n\n/**\n * Generate the access_token using the client_id and client_secret\n * @param callback\n */\nrequestManager.generateAccessToken = function (callback) {\n  var error;\n\n  callback = preConditions.getCallback(callback);\n\n  return new Promise(function (resolve, reject) {\n    // If the access_token is already set, return it from configurations\n    if (configurations.getAccessToken()) {\n      resolve(configurations.getAccessToken());\n      return callback.apply(null, [null, configurations.getAccessToken()]);\n    }\n\n    // If the SDK is not yet configure\n    if (!configurations.getClientId() || !configurations.getClientSecret()) {\n      error = new MercadoPagoError('Must set client_id and client_secret', '', 500, '');\n      reject(error);\n      return callback.apply(null, [error, null]);\n    }\n\n    return requestManager.exec({\n      path: '/oauth/token',\n      method: 'POST',\n      payload: {\n        client_id: configurations.getClientId(),\n        client_secret: configurations.getClientSecret(),\n        grant_type: 'client_credentials'\n      }\n    }).then(function (response) {\n      // Save token on configurations\n      // configurations.setAccessToken(response.body.access_token).setRefreshToken(response.body.refresh_token);\n\n      resolve(response.body.access_token);\n      return callback.apply(null, [null, response.body.access_token]);\n    }).catch(function (err) {\n      reject(err);\n      return callback.apply(null, [err, null]);\n    });\n  });\n};\n\n/**\n * Set the new access_token using the previous one & the refresh_token\n * @param callback\n * @returns {*}\n */\nrequestManager.refreshAccessToken = function (callback) {\n  var error;\n\n  callback = preConditions.getCallback(callback);\n\n  return new Promise(function (resolve, reject) {\n    // Check if the refresh token is configure (require to refresh the access_token)\n    if (!configurations.getRefreshToken()) {\n      error = new MercadoPagoError('You need the refresh_token to refresh the access_token', '', 500, '');\n      reject(error);\n      return callback.apply(null, [error, null]);\n    }\n\n    return requestManager.exec({\n      path: '/oauth/token',\n      method: 'POST',\n      payload: {\n        client_secret: configurations.getAccessToken(),\n        grant_type: 'refresh_token'\n      }\n    }).then(function (response) {\n      configurations.setAccessToken(response.body.access_token)\n        .setRefreshToken(response.body.refresh_token);\n\n      resolve(response.body.access_token);\n      return callback.apply(null, [null, response.body.access_token]);\n    }).catch(function (err) {\n      reject(err);\n      return callback.apply(null, [err, null]);\n    });\n  });\n};\n\n/**\n * Get user access_token (mpconnect) using the access_token, code, redirect_uri\n * @param clientSecret - access_token from MercadoPago\n * @param authorizationCode - authrozication_code obtain from redirectURI\n * @param redirectURI - The one you use for obtaining the authrozication_code\n * @param callback\n */\nrequestManager.getUserCredentials = function (clientSecret, authorizationCode, redirectURI, callback) {\n  callback = preConditions.getCallback(callback);\n\n  return new Promise(function (resolve, reject) {\n    return requestManager.exec({\n      path: '/oauth/token',\n      method: 'POST',\n      payload: {\n        client_secret: clientSecret,\n        code: authorizationCode,\n        redirect_uri: redirectURI,\n        grant_type: 'authorization_code'\n      }\n    }).then(function (response) {\n      resolve(response);\n      return callback.apply(null, [null, response]);\n    }).catch(function (err) {\n      reject(err);\n      return callback.apply(null, [err, null]);\n    });\n  });\n};\n\n/**\n * Build the request using the options send and the configurations\n * @param options\n * @returns {object}\n */\nrequestManager.buildRequest = function (options) {\n  var req = {};\n  var schemaErrors = [];\n\n  req.uri = (options.base_url) ? options.base_url + options.path : configurations.getBaseUrl() + options.path;\n  req.method = options.method;\n  req.headers = {\n    'user-agent': configurations.getUserAgent(),\n    accept: (options.headers && options.headers.accept) ? options.headers.accept : requestManager.JSON_MIME_TYPE,\n    'content-type': (options.headers && options.headers['content-type'])\n      ? options.headers['content-type'] : requestManager.JSON_MIME_TYPE\n  };\n  req.qs = (options.config && options.config.qs) ? options.config.qs : {}; // Always set the querystring object\n  req.json = true; // Autoparse the response to JSON\n\n  if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {\n    // Set idempotency header if the resource needs idempotency of the config specified one\n    if (options.idempotency || (options.config && options.config.idempotency)) {\n      req.headers['x-idempotency-key'] = options.config.idempotency || uuid.v4();\n    }\n    if (req.headers['content-type'] === requestManager.JSON_MIME_TYPE) {\n      // If there is a schema available, validate the payload before continue\n      if (options.schema) {\n        schemaErrors = validation.validate(options.schema, options.payload);\n\n        if (schemaErrors.length > 0) {\n          throw new Error(validation.generateErrorMessage(schemaErrors));\n        }\n      }\n\n      req.json = options.payload;\n    } else {\n      req.form = options.payload;\n    }\n  }\n\n  // Always add the access_token to the querystring\n  req.qs.access_token = options.access_token;\n  // Requires SSL certificates be valid\n  req.strictSSL = true;\n\n  return req;\n};\n\n/**\n * Executes the request build with the options sent\n * @param options\n * @param callback\n */\nrequestManager.exec = function (options, callback) {\n  callback = preConditions.getCallback(callback);\n\n  return new Promise(function (resolve, reject) {\n    var req;\n    var mpResponse;\n    var mpError;\n\n    try {\n      req = requestManager.buildRequest(options);\n    } catch (e) {\n      reject(e);\n      return callback.apply(null, [e, null]);\n    }\n\n    return requestManager.REST_CLIENT(req, function (error, response, body) {\n      if (error) {\n        // Create a mercadopagoError allowing to retry the operation\n        mpError = new MercadoPagoError(error.message, null, null, req.headers['x-idempotency-key'], options, this);\n        reject(mpError);\n        return callback.apply(null, [mpError, null]);\n      }\n\n      if (response.statusCode < 200 || (response.statusCode >= 300 && response.statusCode !== 304)) {\n        // Create a mercadopagoError allowing to retry the operation\n        mpError = new MercadoPagoError(body.message, body.cause, response.statusCode, req.headers['x-idempotency-key'],\n          options, this);\n        reject(mpError);\n        return callback.apply(null, [mpError, null]);\n      }\n\n      // Create a mercadopagoResponse to be returned\n      mpResponse = new MercadopagoResponse(body, response.statusCode, req.headers['x-idempotency-key'],\n        body.paging, options, this);\n\n      resolve(mpResponse);\n      return callback.apply(null, [null, mpResponse]);\n    });\n  }.bind(this));\n};\n\n/**\n * Get path params key names from a String containing the path. Exp: '/v1/payments/:id' (Generate an array with :id)\n * @param path\n * @returns {Array}\n */\nrequestManager.getPathParamsKeyNames = function (path) {\n  return path.match(/(:[a-z|A-Z|_|-]*)/g) || [];\n};\n\n/**\n * Object.assign polyfill\n * @param target\n * @returns {any}\n */\nrequestManager.clone = function (target) {\n  if (target == null) { // TypeError if undefined or null\n    throw new TypeError('Cannot convert undefined or null to object');\n  }\n\n  var to = Object(target);\n\n  for (var index = 1; index < arguments.length; index++) {\n    var nextSource = arguments[index];\n\n    if (nextSource != null) { // pasamos si es undefined o null\n      for (var nextKey in nextSource) {\n        // Evita un error cuando 'hasOwnProperty' ha sido sobrescrito\n        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n          to[nextKey] = nextSource[nextKey];\n        }\n      }\n    }\n  }\n  return to;\n};\n",null]}